/*! For license information please see service_worker.js.LICENSE.txt */
(()=>{var e={590:()=>{},817:()=>{}},t={};function n(r){var s=t[r];if(void 0!==s)return s.exports;var a=t[r]={exports:{}};return e[r](a,a.exports,n),a.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{"use strict";class e{refCount(e){return t("refCount")}incRef(e){return t("incRef")}timerAvailable(){return!0}time(e){return t("time")}read(e){return t("read")}readSync(e){return t("readSync")}readToGPU(e,n){return t("readToGPU")}numDataIds(){return t("numDataIds")}disposeData(e,n){return t("disposeData")}write(e,n,r){return t("write")}move(e,n,r,s,a){return t("move")}createTensorFromGPUData(e,n,r){return t("createTensorFromGPUData")}memory(){return t("memory")}floatPrecision(){return t("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return t("dispose")}}function t(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function r(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function s(e){r(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function a(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function i(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function o(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function l(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function c(e){return"string"==typeof e||e instanceof String}function u(e){return Array.isArray(e)?u(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":"number"==typeof e?"float32":c(e)?"string":"boolean"==typeof e?"bool":"float32"}function h(e){return!!(e&&e.constructor&&e.call&&e.apply)}function d(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function f(e,t,n,r=!1){const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++)s[t]=f(e+t*o,i,n,r)}return s}function p(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return f(0,e,t,n)}function m(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function g(e){e.forEach((t=>{r(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function y(e){return e&&e.then&&"function"==typeof e.then}const b="tfjsflags";class w{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=T,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(I().getBool("IS_TEST")||I().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];I().getBool("IS_TEST")||I().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(y(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);b in e&&e[b].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}function T(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}function I(){return E}let v,E=null;function k(){if(null==v){let e;if("undefined"!=typeof window)e=window;else if(void 0!==n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}v=e}return v}function S(e,t){const n=function(){const e=k();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const x="Cast",_="Identity",N="Tile",A="FromPixels",R=S("kernelRegistry",(()=>new Map)),M=S("gradRegistry",(()=>new Map));function D(e,t){const n=function(e,t){return`${t}_${e}`}(e,t);return R.get(n)}function B(e){return M.get(e)}function F(e){const t=R.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function P(...e){I().getBool("IS_TEST")||I().getBool("PROD")||console.warn(...e)}function O(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function C(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=U(e)),I().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function $(){return I().platform.now()}function L(e,t="utf-8"){return t=t||"utf-8",I().platform.decode(e,t)}function z(e){return null!=I().platform.isTypedArray?I().platform.isTypedArray(e):O(e)}function U(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||y(e)||null==e||z(e)&&n)t.push(e);else if(Array.isArray(e)||z(e))for(let r=0;r<e.length;++r)U(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)U(e[s],t,n)}return t}class G{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new W)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let a;const i=$();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:$()-i})}if(I().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){const n=r[t];n.data().then((t=>{j(t,n.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function j(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class W{logKernelProfile(e,t,n,r,s,a){const i="number"==typeof r?o(`${r}ms`,9):r.error,l=o(e,25),c=t.rank,u=t.size,h=o(t.shape.toString(),14);let d="";for(const e in s){const n=s[e];if(null!=n){const r=n.shape||t.shape,s=r.length;d+=`${e}: ${s}D ${s>0?r:""} `}}console.log(`%c${l}\t%c${i}\t%c${c}D ${h}\t%c${u}\t%c${d}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function V(e,t,n,r){const s=d(t),i=function(e,t,n,r){const s=a(t),i=r[r.length-1],o=new Array(i).fill(0),l=t.length,c="complex64"===n?J(e):e;if(l>1)for(let e=0;e<s/i;e++){const t=e*i;for(let e=0;e<i;e++)o[e]=Math.max(o[e],H(c[t+e],0,n).length)}return o}(e,t,n,s),o=t.length,l=q(e,t,n,s,i),c=["Tensor"];return r&&(c.push(`  dtype: ${n}`),c.push(`  rank: ${o}`),c.push(`  shape: [${t}]`),c.push("  values:")),c.push(l.map((e=>"    "+e)).join("\n")),c.join("\n")}function H(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:c(e)?`'${e}'`:"bool"===n?K(e):parseFloat(e.toFixed(7)).toString(),o(r,t)}function K(e){return 0===e?"false":"true"}function q(e,t,n,r,s,a=!0){const i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l)return"complex64"===n?[H(J(e)[0],0,n)]:"bool"===n?[K(e[0])]:[e[0].toString()];if(1===l){if(o>20){const t=3*i;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(r=J(r),a=J(a)),["["+r.map(((e,t)=>H(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>H(e,s[o-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?J(e):Array.from(e)).map(((e,t)=>H(e,s[t],n))).join(", ")+"]"]}const c=t.slice(1),u=r.slice(1),h=r[0]*i,d=[];if(o>20){for(let t=0;t<3;t++){const r=t*h,a=r+h;d.push(...q(e.slice(r,a),c,n,u,s,!1))}d.push("...");for(let t=o-3;t<o;t++){const r=t*h,a=r+h;d.push(...q(e.slice(r,a),c,n,u,s,t===o-1))}}else for(let t=0;t<o;t++){const r=t*h,a=r+h;d.push(...q(e.slice(r,a),c,n,u,s,t===o-1))}const f=2===l?",":"";d[0]="["+(o>0?d[0]+f:"");for(let e=1;e<d.length-1;e++)d[e]=" "+d[e]+f;let p=",\n";for(let e=2;e<l;e++)p+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":p),d}function J(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class Q{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=a(e),null!=n){const e=n.length;r(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||function(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}(t,this.size),this.strides=d(e)}set(e,...t){0===t.length&&(t=[0]),r(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Y().makeTensor(this.values,this.shape,this.dtype)}}let Y=null,X=null,Z=null;class ee{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=a(e),this.strides=d(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return X.buffer(this.shape,this.dtype,e)}bufferSync(){return X.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return p(this.shape,e,"complex64"===this.dtype)}arraySync(){return p(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=Y().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>L(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Y().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Y().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>L(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Y().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Y().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return X.print(this,e)}clone(){return this.throwIfDisposed(),X.clone(this)}toString(e=!1){return V(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),X.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Y().makeVariable(this,e,t,n)}}function te(){return S("Tensor",(()=>ee))}Object.defineProperty(ee,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),te();class ne extends ee{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!i(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Y().disposeTensor(this),this.dataId=e.dataId,Y().incRef(this,null)}dispose(){Y().disposeVariable(this),this.isDisposedInternal=!0}}var re,se,ae,ie,oe;Object.defineProperty(ne,Symbol.hasInstance,{value:e=>e instanceof ee&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(re||(re={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(se||(se={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(ae||(ae={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(ie||(ie={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(oe||(oe={}));const le={float32:ie,int32:se,bool:ae,complex64:oe};function ce(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function ue(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function he(e,t){if(e.dtype===t.dtype)return[e,t];const n=function(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return le[e][t]}(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function de(e){const t=[];return fe(e,t,new Set),t}function fe(e,t,n){if(null==e)return;if(e instanceof ee)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=e;for(const e in s){const r=s[e];n.has(r)||(n.add(r),fe(r,t,n))}}function pe(e){return null!=e.kernelName}class me{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class ge{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new me}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(P(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new G(this.backendInstance),!0}setupRegisteredKernels(){F(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){F(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(t){const n=this.registryFactory[t];if(null==n)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const r=n.factory();if(!r||r instanceof e||"function"!=typeof r.then)return this.registry[t]=r,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,n=r.then((n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0)))).catch((n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,P(`Initialization of backend ${t} failed`),P(n.stack||n.message)),!1)));return this.pendingBackendInit=n,{success:n,asyncInit:!0}}}catch(e){return P(`Initialization of backend ${t} failed`),P(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return ge.nextTensorId++}nextVariableId(){return ge.nextVariableId++}clone(e){const t=be.runKernel(_,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e};return be.runKernel(x,t,{dtype:"float32"})}})),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==D(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach((e=>{s+="complex64"===e.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const s=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;let o,l;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=pe(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(pe(e)){const{kernelName:t,inputs:a,attrs:i}=e;null==this.backendName&&this.backend;const c=D(t,this.backendName);r(null!=c,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),o=()=>{const e=this.backend.numDataIds();l=c.kernelFunc({inputs:a,attrs:i,backend:this.backend});const r=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,r);const o=r.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(s){const e=this.getTensorsForGradient(t,a,o);n=this.saveTensorsForBackwardMode(e)}return o}}else{const{forwardFunc:t}=e,r=e=>{s&&(n=e.map((e=>this.keep(this.clone(e)))))};o=()=>{const e=this.backend.numDataIds();l=this.tidy((()=>t(this.backend,r)));const n=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}const{inputs:u,attrs:h}=e,d=pe(e)?null:e.backwardsFunc;let f;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(c,u,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs):t=o()})),s&&this.addTapeNode(c,u,t,d,n,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((e=>null!=u[e]?u[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const s=B(e);if(null!=s){const e=s.inputsToSave||[],a=s.outputsToSave||[];let i;s.saveAllInputs?(r(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),i=Object.keys(t).map((e=>t[e]))):i=e.map((e=>t[e]));const o=n.filter(((e,t)=>a[t]));return i.concat(o)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&c(e[0])&&(s=e.map((e=>function(e,t="utf-8"){return t=t||"utf-8",I().platform.encode(e,t)}(e))));const a=r.write(s,t,n),i=new ee(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:s}=e,a=new ee(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new ne(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*l(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof ne||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*l(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=B(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=m(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=de(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,s=!1){if(r(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const o=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));r(o instanceof ee,(()=>"The result y returned by f() must be a tensor."));const l=function(e,t,n){const r={},s={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const a=e[n],i=a.inputs;for(const e in i){const n=i[e];let o=!1;for(let e=0;e<t.length;e++)if(r[n.id]){a.outputs.forEach((e=>r[e.id]=!0)),o=!0,s[a.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(a[n.outputs[e].id]){for(const e in r)a[r[e].id]=!0,i[n.id]=!0;break}}const o=[];for(let t=0;t<e.length;t++){const n=e[t];if(s[n.id]&&i[n.id]){const e={};for(const t in n.inputs){const s=n.inputs[t];r[s.id]&&(e[t]=s)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,o.push(t)}}return o}(this.state.activeTape,t,o);if(!s&&0===l.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[o.id]=null==n?function(e){const t=function(e,t){const n=m(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}(a(e),"float32");return be.makeTensor(t,e,"float32")}(o.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],o=[];if(a.outputs.forEach((t=>{const n=e[t.id];null!=n?o.push(n):o.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const l=a.gradient(o);for(const t in a.inputs){if(!(t in l))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(l)}.`);const s=n((()=>l[t]()));if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const o=a.inputs[t];if(!i(s.shape,o.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${o.shape}'`);if(null==e[o.id])e[o.id]=s;else{const t=e[o.id];e[o.id]=r(t,s),t.dispose()}}}}(e,l,(e=>this.tidy(e)),we);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:o,grads:r}}))}customGrad(e){return r(h(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;r(t.every((e=>e instanceof ee)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const s={};return t.forEach(((e,t)=>{s[t]=e})),this.runKernelFunc({forwardFunc:(s,a)=>(n=e(...t,a),r(n.value instanceof ee,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),r(h(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,s)=>{const a=n.gradFunc(e,s),i=Array.isArray(a)?a:[a];r(i.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),r(i.every((e=>e instanceof ee)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return i.forEach(((e,t)=>{o[t]=()=>e})),o},inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=$(),n=await this.backend.time(e);return n.wallMs=$()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new me;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function ye(){const e=k();if(null==e._tfengine){const t=new w(e);e._tfengine=new ge(t)}var t;return t=e._tfengine.ENV,E=t,Y=()=>e._tfengine,e._tfengine}ge.nextTensorId=0,ge.nextVariableId=0;const be=ye();function we(e,t){const n={a:e,b:t};return be.runKernel("Add",n)}const Te=I();Te.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Te.registerFlag("IS_BROWSER",(()=>"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope)),Te.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),Te.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Te.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Te.registerFlag("PROD",(()=>!1)),Te.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Te.getBool("DEBUG"))),Te.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Te.registerFlag("IS_TEST",(()=>!1)),Te.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Te.getBool("DEBUG"))),Te.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Te.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Te.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));class Ie{static join(e){return new Ie(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>z(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+r.byteLength;this.shards.push({buffer:r,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),s=new Uint8Array(r);let a=0;for(let r=n;r<this.shards.length;r++){const n=this.shards[r],i=e+a-n.start,o=a,l=Math.min(t,n.end)-n.start,c=new Uint8Array(n.buffer,i,l-i);if(s.set(c,o),a+=c.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(0===a)return s;a<0?r=s:n=s+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}const ve="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function Ee(e){return ve?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function ke(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function Se(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:Ee(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:Ee(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Ie(e.weightData).byteLength}}function xe(e){const t=[];for(const n of e)t.push(...n.weights);return t}class _e{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==_e.instance&&(_e.instance=new _e),_e.instance}static registerSaveRouter(e){_e.getInstance().saveRouters.push(e)}static registerLoadRouter(e){_e.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return _e.getHandlers(e,"save")}static getLoadHandlers(e,t){return _e.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?_e.getInstance().loadRouters:_e.getInstance().saveRouters).forEach((t=>{const s=t(e,n);null!==s&&r.push(s)})),r}}const Ne="tensorflowjs",Ae="models_store",Re="model_info_store";function Me(){if(!I().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function De(e){const t=e.result;t.createObjectStore(Ae,{keyPath:"modelPath"}),t.createObjectStore(Re,{keyPath:"modelPath"})}class Be{constructor(e){if(this.indexedDB=Me(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(Ne,1);r.onupgradeneeded=()=>De(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(Ae,"readonly"),r=t.objectStore(Ae).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{t.weightData=Ie.join(t.weightData);const r=Se(t),a=s.transaction(Re,"readwrite");let i,o,l=a.objectStore(Re);try{i=l.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(e){return n(e)}i.onsuccess=()=>{o=s.transaction(Ae,"readwrite");const i=o.objectStore(Ae);let c;try{c=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(e){return n(e)}c.onsuccess=()=>e({modelArtifactsInfo:r}),c.onerror=e=>{l=a.objectStore(Re);const t=l.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(c.error)),t.onerror=e=>(s.close(),n(c.error))}},i.onerror=e=>(s.close(),n(i.error)),a.oncomplete=()=>{null==o?s.close():o.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)}))}}Be.URL_SCHEME="indexeddb://";const Fe=e=>{return I().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Be.URL_SCHEME)?(t=e.slice(Be.URL_SCHEME.length),new Be(t)):null;var t};_e.registerSaveRouter(Fe),_e.registerLoadRouter(Fe);class Pe{constructor(){this.indexedDB=Me()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(Ne,1);n.onupgradeneeded=()=>De(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(Re,"readonly"),a=s.objectStore(Re).getAll();a.onsuccess=()=>{const t={};for(const e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(Be.URL_SCHEME)?t.slice(Be.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(Ne,1);r.onupgradeneeded=()=>De(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(Re,"readwrite"),i=a.objectStore(Re),o=i.get(e);let l;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{l=s.transaction(Ae,"readwrite");const r=l.objectStore(Ae).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=a,r.onerror=e=>(a(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}}const Oe="/",Ce="tensorflowjs_models",$e="info",Le="model_topology",ze="weight_specs",Ue="weight_data",Ge="model_metadata";function je(e){return{info:[Ce,e,$e].join(Oe),topology:[Ce,e,Le].join(Oe),weightSpecs:[Ce,e,ze].join(Oe),weightData:[Ce,e,Ue].join(Oe),modelMetadata:[Ce,e,Ge].join(Oe)}}function We(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Ve(e){const t=e.split(Oe);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Oe)}class He{constructor(e){if(!I().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=je(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=Se(e),s=Ie.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(ve)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(s));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch(e){throw We(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(ve){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(a),t}}He.URL_SCHEME="localstorage://";const Ke=e=>{return I().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(He.URL_SCHEME)?(t=e.slice(He.URL_SCHEME.length),new He(t)):null;var t};_e.registerSaveRouter(Ke),_e.registerLoadRouter(Ke);class qe{constructor(){r(I().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),r("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=Ce+Oe,n=Oe+$e;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);s.startsWith(t)&&s.endsWith(n)&&(e[Ve(s)]=JSON.parse(this.LS.getItem(s)))}return e}async removeModel(e){var t;const n=je(e=(t=e).startsWith(He.URL_SCHEME)?t.slice(He.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return We(n),r}}class Je{constructor(){this.managers={}}static getInstance(){return null==Je.instance&&(Je.instance=new Je),Je.instance}static registerManager(e,t){r(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),r(e.length>0,(()=>"scheme must not be an empty string."));const n=Je.getInstance();r(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=Je.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Je.getInstance().managers)}}class Qe{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&I().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(e,t)}isTypedArray(e){return O(e)}}if(I().get("IS_BROWSER")){I().setPlatform("browser",new Qe);try{Je.registerManager(He.URL_SCHEME,new qe)}catch(e){}try{Je.registerManager(Be.URL_SCHEME,new Pe)}catch(e){}}let Ye;function Xe(e,t){let n=e;if(z(e))return"string"===t?[]:[e.length];if(ce(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(ue(e))return[e.buffer.size/(null==t?4:l(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||z(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&I().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Ze(e,r,[]),r}function Ze(e,t,n){if(n=n||[],!Array.isArray(e)&&!z(e))return void r(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));r(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),r(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const s=t.slice(1);for(let t=0;t<e.length;++t)Ze(e[t],s,n.concat(t))}function et(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function tt(e,t,n,r="numeric"){if(e instanceof te())return et(r,e.dtype,t,n),e;let s=u(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),et(r,s,t,n),null==e||!z(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=Xe(e,s);z(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?C(e,s):U(e,[],!0);return be.makeTensor(i,a,s)}function nt(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const s=(...e)=>{be.startScope(n);try{const t=r(...e);return y(t)&&console.error("Cannot return a Promise inside of tidy."),be.endScope(t),t}catch(e){throw be.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}I().get("IS_NODE")&&!I().get("IS_BROWSER")&&I().setPlatform("node",new class{constructor(){this.util=n(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=I().global.fetch?I().global.fetch(e,t):(null==Ye&&(Ye=n(817)),Ye(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});const rt=nt({cast_:function(e,t){const n=tt(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return be.runKernel(x,r,s)}}),st=nt({clone_:function(e){const t={x:tt(e,"x","clone","string_or_numeric")};return be.runKernel(_,t)}});ye();const at={buffer:function(e,t="float32",n){return t=t||"float32",g(e),new Q(e,t,n)},cast:rt,clone:st,print:function(e,t=!1){console.log(e.toString(t))}};function it(e,t){return be.tidy(e,t)}function ot(e){de(e).forEach((e=>e.dispose()))}function lt(){return be.backendName}X=at,Z=function(e){I().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};const ct=nt({add_:function(e,t){let n=tt(e,"a","add"),r=tt(t,"b","add");[n,r]=he(n,r);const s={a:n,b:r};return be.runKernel("Add",s)}}),ut=nt({floorDiv_:function(e,t){let n=tt(e,"a","floorDiv"),r=tt(t,"b","floorDiv");[n,r]=he(n,r);const s={a:n,b:r};return be.runKernel("FloorDiv",s)}}),ht=nt({div_:function(e,t){let n=tt(e,"a","div"),r=tt(t,"b","div");if([n,r]=he(n,r),"int32"===n.dtype&&"int32"===r.dtype)return ut(n,r);const s={a:n,b:r};return be.runKernel("RealDiv",s,{})}}),dt=nt({mul_:function(e,t){let n=tt(e,"a","mul"),r=tt(t,"b","mul");[n,r]=he(n,r);const s={a:n,b:r};return be.runKernel("Multiply",s)}}),ft=nt({sqrt_:function(e){const t={x:tt(e,"x","sqrt","float32")};return be.runKernel("Sqrt",t)}}),pt=nt({square_:function(e){const t=tt(e,"x","square");return be.runKernel("Square",{x:t},{})}}),mt=nt({zerosLike_:function(e){const t={x:tt(e,"x","zerosLike")};return be.runKernel("ZerosLike",t)}});function gt(e,t,n,s){if(null==s)s=u(e);else if("complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(ue(e)||ce(e)){if("float32"!==s&&"int32"!==s)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return be.backend.createTensorFromGPUData(e,t||n,s)}if(!z(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){g(t);const e=a(t),s=a(n);r(e===s,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${s}`));for(let e=0;e<n.length;++e){const s=n[e],i=e!==n.length-1||s!==a(t.slice(e));r(n[e]===t[e]||!i,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return z(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==s?C(e,s):U(e,[],!0),be.makeTensor(e,t,s)}function yt(e,t){if((z(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&z(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return gt(e,[],[],t)}const bt=new Map,wt=new Map;class Tt{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class It{constructor(){this.classNameMap={}}static getMap(){return null==It.instance&&(It.instance=new It),It.instance}static register(e){It.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function vt(e,t,n){r(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),r("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),r(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),void 0===t&&(t="Custom"),void 0===n&&(n=e.className);const s=t+">"+n;return It.register(e),bt.set(s,e),wt.set(e,s),e}class Et extends Tt{minimize(e,t=!1,n){const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:s[e.name]})));this.applyGradients(e)}else this.applyGradients(s);return ot(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){r(h(e),(()=>"The f passed in variableGrads(f) must be a function")),r(null==t||Array.isArray(t)&&t.every((e=>e instanceof ne)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in be.registeredVariables)t.push(be.registeredVariables[e])}const s=n?t.filter((e=>!e.trainable)):null,a=t.length;r((t=t.filter((e=>e.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));const{value:i,grads:o}=be.gradients(e,t,null,!0);r(o.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),r(0===i.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`));const l={};return t.forEach(((e,t)=>{null!=o[t]&&(l[e.name]=o[t])})),null!=s&&s.forEach((e=>l[e.name]=null)),{value:i,grads:l}}(e,t)}dispose(){null!=this.iterations_&&ot(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:yt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}function kt(e,t,n){g(e);const r={shape:e,value:t,dtype:n=n||u(t)};return be.runKernel("Fill",{},r)}Object.defineProperty(Et,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});const St=nt({pow_:function(e,t){let n=tt(e,"base","pow"),r=tt(t,"exp","pow");[n,r]=he(n,r);const s={a:n,b:r};return be.runKernel("Pow",s)}}),xt=nt({sub_:function(e,t){let n=tt(e,"a","sub"),r=tt(t,"b","sub");[n,r]=he(n,r);const s={a:n,b:r};return be.runKernel("Sub",s)}}),_t=nt({abs_:function(e){const t=tt(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return be.runKernel("ComplexAbs",e)}{const e={x:t};return be.runKernel("Abs",e)}}});function Nt(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];null==a&&(a=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===a)r[n-s-1]=i;else if(1===i)r[n-s-1]=a;else{if(a!==i)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);r[n-s-1]=a}}return r}const At=nt({maximum_:function(e,t){let n=tt(e,"a","maximum"),r=tt(t,"b","maximum");[n,r]=he(n,r),"bool"===n.dtype&&(n=rt(n,"int32"),r=rt(r,"int32")),Nt(n.shape,r.shape);const s={a:n,b:r};return be.runKernel("Maximum",s)}});class Rt extends Et{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=be.registeredVariables[t];it((()=>{const e=ct(dt(this.c,r),s);s.assign(e)}))})),this.incrementIterations()}setLearningRate(e){var t;this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=(t=yt(-e),be.keep(t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}const Mt=[class extends Et{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=be.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=be.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:it((()=>mt(r).variable(s)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:it((()=>mt(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;it((()=>{const e=ct(dt(i,this.rho),dt(pt(a),1-this.rho)),t=dt(ht(ft(ct(o,this.epsilon)),ft(ct(i,this.epsilon))),a),n=ct(dt(o,this.rho),dt(pt(t),1-this.rho));i.assign(e),o.assign(n);const s=ct(dt(t,-this.learningRate),r);r.assign(s)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(ot(this.accumulatedGrads.map((e=>e.variable))),ot(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},class extends Et{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=be.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:it((()=>kt(r.shape,this.initialAccumulatorValue).variable(e)))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;it((()=>{const e=ct(a,pt(s));a.assign(e);const t=ct(dt(ht(s,ft(ct(e,be.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&ot(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},class extends Et{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],it((()=>{this.accBeta1=yt(t).variable(),this.accBeta2=yt(n).variable()})),null==r&&(this.epsilon=be.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);it((()=>{const n=xt(1,this.accBeta1),r=xt(1,this.accBeta2);t.forEach(((t,s)=>{const a=be.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:it((()=>mt(a).variable(i)))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:it((()=>mt(a).variable(i)))});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,c=this.accumulatedSecondMoment[s].variable,u=ct(dt(l,this.beta1),dt(o,1-this.beta1)),h=ct(dt(c,this.beta2),dt(pt(o),1-this.beta2)),d=ht(u,n),f=ht(h,r);l.assign(u),c.assign(h);const p=ct(dt(ht(d,ct(ft(f),this.epsilon)),-this.learningRate),a);a.assign(p)})),this.accBeta1.assign(dt(this.accBeta1,this.beta1)),this.accBeta2.assign(dt(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&ot(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&ot(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),it((()=>{this.accBeta1.assign(St(this.beta1,this.iterations_+1)),this.accBeta2.assign(St(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},class extends Et{static get className(){return"Adamax"}constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],it((()=>{this.iteration=yt(0).variable(),this.accBeta1=yt(t).variable()})),null==r&&(this.epsilon=be.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);it((()=>{const n=xt(1,this.accBeta1),r=ht(-this.learningRate,ct(dt(this.iteration,this.decay),1));t.forEach(((t,s)=>{const a=be.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:mt(a).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:mt(a).variable(i)});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,c=this.accumulatedWeightedInfNorm[s].variable,u=ct(dt(l,this.beta1),dt(o,1-this.beta1)),h=dt(c,this.beta2),d=_t(o),f=At(h,d);l.assign(u),c.assign(f);const p=ct(dt(ht(r,n),ht(u,ct(f,this.epsilon))),a);a.assign(p)})),this.iteration.assign(ct(this.iteration,1)),this.accBeta1.assign(dt(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&ot(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&ot(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},class extends Rt{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=yt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=be.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:it((()=>mt(r).variable(e)))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&it((()=>{let e;const t=ct(dt(this.m,s),a);e=this.useNesterov?ct(dt(this.c,ct(a,dt(t,this.m))),r):ct(dt(this.c,t),r),s.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&ot(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},class extends Et{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=be.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=be.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:it((()=>mt(r).variable(s)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:it((()=>mt(r).variable(s)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:it((()=>mt(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;it((()=>{const e=ct(dt(i,this.decay),dt(pt(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=ct(dt(t,this.decay),dt(a,1-this.decay)),l=ht(dt(a,this.learningRate),ft(xt(e,ct(pt(s),this.epsilon)))),c=ct(dt(o,this.momentum),l);i.assign(e),t.assign(s),o.assign(c);const u=xt(r,c);r.assign(u)}else{const e=ct(dt(i,this.decay),dt(pt(a),1-this.decay)),t=ct(dt(o,this.momentum),ht(dt(a,this.learningRate),ft(ct(e,this.epsilon))));i.assign(e),o.assign(t);const n=xt(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&ot(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&ot(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&ot(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},Rt];function Dt(e){return new Promise((e=>setTimeout(e))).then(e)}class Bt{constructor(e){if(!I().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Bt.URL_SCHEME)&&(e=e.slice(Bt.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Ie.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=ke(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=r,await Dt((()=>s.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Dt((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Se(e)}}}}function Ft(e,t,n,s){!function(e){r(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){r(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),r(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),r(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,s=null==s?1:s);let a=0;return Promise.all(e.map((r=>(r.then((r=>{const i=n+ ++a/e.length*(s-n);return t(i),r})),r))))}async function Pt(e,t){null==t&&(t={});const n=null==t.fetchFunc?I().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),s=(null==t.onProgress?await Promise.all(r):await Ft(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(s):await Ft(s,t.onProgress,.5,1)}Bt.URL_SCHEME="downloads://",_e.registerSaveRouter((e=>I().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Bt.URL_SCHEME)?function(e="model"){return new Bt(e)}(e.slice(Bt.URL_SCHEME.length)):null));class Ot{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(r("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=I().platform.fetch,r(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&r(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=ke(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=Ie.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:Se(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){return this.loadOptions.streamWeights?this.loadStream():async function(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),function(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}(e,n,r)}(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=xe(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?I().platform.fetch:t.fetchFunc;let s,a=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;a<e.length;){if(!s){const n=(await r(e[a],t.requestInit,{isBinary:!0})).body;s=n.getReader()}const{done:o,value:l}=await s.read();if(!o)return void n.enqueue(l);a++,s=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,a/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(t),s=this.weightPathPrefix||n,a=[],i=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):a.push(s+e+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){const t=await this.getWeightUrls(e);return[xe(e),await Pt(t,this.loadOptions)]}}function Ct(e){return null!=e.match(Ot.URL_SCHEME_REGEX)}Ot.URL_SCHEME_REGEX=/^https?:\/\//;const $t=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Ct(e))):Ct(e),n)return function(e,t){return new Ot(e,t)}(e,t)}return null};let Lt;_e.registerSaveRouter($t),_e.registerLoadRouter($t);const zt=nt({fromPixels_:function(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,i=!1,o=!1,l=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)i=!0;else if(null!=e.getContext)o=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);l=!0}if(null!=D(A,be.backendName)){const n={pixels:e},r={numChannels:t};return be.runKernel(A,n,r)}const[c,u]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];let h,d;if(o)h=e.getContext("2d").getImageData(0,0,c,u).data;else if(r||n)h=e.data;else if(i||a||l){if(null==Lt)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Lt=new OffscreenCanvas(1,1).getContext("2d")}else Lt=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Lt.canvas.width=c,Lt.canvas.height=u,Lt.drawImage(e,0,0,c,u),h=Lt.getImageData(0,0,c,u).data}if(4===t)d=new Int32Array(h);else{const e=c*u;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=h[4*n+e]}return function(e,t,n){if(s(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Xe(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return gt(e,t,r,n)}(d,[u,c,t],"int32")}}),Ut=nt({concat_:function(e,t=0){r(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=function(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,s)=>tt(e,`${t}[${s}]`,n,r)))}(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return st(n[0]);const s=n,a={axis:t};return be.runKernel("Concat",s,a)}}),Gt=nt({concat2d_:function(e,t){return Ut(e,t)}}),jt=nt({expandDims_:function(e,t=0){const n=tt(e,"x","expandDims","string_or_numeric");r(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const s={input:n},a={dim:t};return be.runKernel("ExpandDims",s,a)}}),Wt=nt({reshape_:function(e,t){const n={x:tt(e,"x","reshape","string_or_numeric")},r={shape:t};return be.runKernel("Reshape",n,r)}}),Vt=nt({sigmoid_:function(e){const t={x:tt(e,"x","sigmoid","float32")};return be.runKernel("Sigmoid",t)}}),Ht=nt({slice_:function(e,t,n){const r=tt(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return be.runKernel("Slice",s,a)}}),Kt=nt({squeeze_:function(e,t){const n=tt(e,"x","squeeze","string_or_numeric");return Wt(n,function(e,t){const n=[],s=[],a=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||a?null:function(e,t){const n=t.length;return r((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),r(e.every((e=>e%1==0)),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}(t,e).sort();let o=0;for(let t=0;t<e.length;++t){if(null!=i){if(i[o]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==i[o]||i[o]>t)&&1===e[t]&&(n.push(e[t]),s.push(t)),i[o]<=t&&o++}1!==e[t]&&(n.push(e[t]),s.push(t))}return{newShape:n,keptDims:s}}(n.shape,t).newShape)}});function qt(e,t){s(e);const n=Xe(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return gt(e,null,n,t)}const Jt=nt({split_:function(e,t,n=0){const r={x:tt(e,"x","split")},s={numOrSizeSplits:t,axis:n};return be.runKernel("SplitV",r,s)}}),Qt=nt({cropAndResize_:function(e,t,n,s,a="bilinear",i=0){const o=tt(e,"image","cropAndResize"),l=tt(t,"boxes","cropAndResize","float32"),c=tt(n,"boxInd","cropAndResize","int32"),u=l.shape[0];r(4===o.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`)),r(2===l.rank&&4===l.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${l.shape}.`)),r(1===c.rank&&c.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${l.shape}.`)),r(2===s.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`)),r(s[0]>=1&&s[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${s}`)),r("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));const h={image:o,boxes:l,boxInd:c},d={method:a,extrapolationValue:i,cropSize:s};return be.runKernel("CropAndResize",h,d)}}),Yt=nt({flipLeftRight_:function(e){const t=tt(e,"image","flipLeftRight","float32");r(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return be.runKernel("FlipLeftRight",n,{})}}),Xt=nt({tile_:function(e,t){const n=tt(e,"x","tile","string_or_numeric");r(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const s={x:n},a={reps:t};return be.runKernel(N,s,a)}}),Zt=nt({grayscaleToRGB_:function(e){const t=tt(e,"image","grayscaleToRGB"),n=t.rank-1,s=t.shape[n];r(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),r(1===s,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`));const a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,Xt(t,a)}}),en=nt({einsum_:function(e,...t){const n=t.map(((e,t)=>tt(e,`tensors${t}`,"einsum"))),r={equation:e};return be.runKernel("Einsum",n,r)}}),tn=nt({rgbToGrayscale_:function(e){const t=tt(e,"image","RGBToGrayscale"),n=t.rank-1,s=t.shape[n];r(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),r(3===s,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`));const a=t.dtype,i=rt(t,"float32"),o=qt([.2989,.587,.114]);let l;switch(t.rank){case 2:l=en("ij,j->i",i,o);break;case 3:l=en("ijk,k->ij",i,o);break;case 4:l=en("ijkl,l->ijk",i,o);break;case 5:l=en("ijklm,m->ijkl",i,o);break;case 6:l=en("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return l=jt(l,-1),rt(l,a)}}),nn=nt({rotateWithOffset_:function(e,t,n=0,s=.5){const a=tt(e,"image","rotateWithOffset","float32");r(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));const i={image:a},o={radians:t,fillValue:n,center:s};return be.runKernel("RotateWithOffset",i,o)}});function rn(e,t,n,s,a,i){null==s&&(s=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==i&&(i=0);const o=e.shape[0];return n=Math.min(n,o),r(0<=s&&s<=1,(()=>`iouThreshold must be in [0, 1], but was '${s}'`)),r(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),r(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),r(1===t.rank,(()=>"scores must be a 1D tensor")),r(t.shape[0]===o,(()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`)),r(0<=i&&i<=1,(()=>`softNmsSigma must be in [0, 1], but was '${i}'`)),{maxOutputSize:n,iouThreshold:s,scoreThreshold:a,softNmsSigma:i}}const sn=nt({nonMaxSuppression_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=tt(e,"boxes","nonMaxSuppression","float32"),i=tt(t,"scores","nonMaxSuppression","float32"),o=rn(a,i,n,r,s),l={maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:s=o.scoreThreshold};return be.runKernel("NonMaxSuppressionV3",{boxes:a,scores:i},l)}});function an(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}(e,t,n||on)}(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function on(e,t){return e>t?1:e<t?-1:0}function ln(e,t,n,r,s,a,i=!1,o=!1,l=!1){const c=[];for(let e=0;e<t.length;e++)t[e]>s&&c.push({score:t[e],boxIndex:e,suppressBeginIndex:0});c.sort(hn);const u=a>0?-.5/a:0,h=[],d=[];for(;h.length<n&&c.length>0;){const t=c.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let n=h.length-1;n>=i;--n){const i=cn(e,a,h[n]);if(i>=r){o=!0;break}if(t.score=t.score*un(r,u,i),t.score<=s)break}t.suppressBeginIndex=h.length,o||(t.score===n?(h.push(a),d.push(t.score)):t.score>s&&an(c,t,hn))}const f=h.length,p=n-f;o&&p>0&&(h.push(...new Array(p).fill(0)),d.push(...new Array(p).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=d),l&&(m.validOutputs=f),m}function cn(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),f=(o-a)*(l-i),p=(h-c)*(d-u);if(f<=0||p<=0)return 0;const m=Math.max(a,c),g=Math.max(i,u),y=Math.min(o,h),b=Math.min(l,d),w=Math.max(y-m,0)*Math.max(b-g,0);return w/(f+p-w)}function un(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function hn(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const dn=nt({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=tt(e,"boxes","nonMaxSuppression"),o=tt(t,"scores","nonMaxSuppression"),l=rn(i,o,n,r,s,a),c={boxes:i,scores:o},u={maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:a=l.softNmsSigma},h=be.runKernel("NonMaxSuppressionV5",c,u);return{selectedIndices:h[0],selectedScores:h[1]}}}),fn=nt({nonMaxSuppressionPadded_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=tt(e,"boxes","nonMaxSuppression"),o=tt(t,"scores","nonMaxSuppression"),l=rn(i,o,n,r,s,null),c={boxes:i,scores:o},u={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:a},h=be.runKernel("NonMaxSuppressionV4",c,u);return{selectedIndices:h[0],validOutputs:h[1]}}}),pn=nt({resizeBilinear_:function(e,t,n=!1,s=!1){const a=tt(e,"images","resizeBilinear");r(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),r(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),r(!1===s||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let i=a,o=!1;3===a.rank&&(o=!0,i=Wt(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,l={images:i},c={alignCorners:n,halfPixelCenters:s,size:t},u=be.runKernel("ResizeBilinear",l,c);return o?Wt(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),mn=nt({resizeNearestNeighbor_:function(e,t,n=!1,s=!1){const a=tt(e,"images","resizeNearestNeighbor");r(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),r(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),r("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),r(!1===s||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let i=a,o=!1;3===a.rank&&(o=!0,i=Wt(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const[]=t,l={images:i},c={alignCorners:n,halfPixelCenters:s,size:t},u=be.runKernel("ResizeNearestNeighbor",l,c);return o?Wt(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),gn=nt({bincount_:function(e,t,n){const s=tt(e,"x","bincount"),a=tt(t,"weights","bincount");r("int32"===s.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`)),r(n>=0,(()=>`size must be non-negative, but got ${n}.`)),r(a.size===s.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${a.shape}.`));const i={x:s,weights:a},o={size:n};return be.runKernel("Bincount",i,o)}}),yn=nt({lessEqual_:function(e,t){let n=tt(e,"a","lessEqual","string_or_numeric"),r=tt(t,"b","lessEqual","string_or_numeric");[n,r]=he(n,r),Nt(n.shape,r.shape);const s={a:n,b:r};return be.runKernel("LessEqual",s)}}),bn=nt({greater_:function(e,t){let n=tt(e,"a","greater","string_or_numeric"),r=tt(t,"b","greater","string_or_numeric");[n,r]=he(n,r),Nt(n.shape,r.shape);const s={a:n,b:r};return be.runKernel("Greater",s)}}),wn=nt({sum_:function(e,t=null,n=!1){let r=tt(e,"x","sum");"bool"===r.dtype&&(r=rt(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return be.runKernel("Sum",s,a)}}),Tn=nt({round_:function(e){const t={x:tt(e,"x","round")};return be.runKernel("Round",t)}}),In=nt({broadcastTo_:function(e,t){let n=tt(e,"broadcastTo","x");const r=n.shape;if(g(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Wt(n,e)}const s=n.shape,a=Array.from(t);for(let e=t.length-1;e>=0;e--)if(s[e]===t[e])a[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===a.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return st(n);const i={x:n},o={reps:a};return be.runKernel(N,i,o)}}),vn=nt({where_:function(e,t,n){const r=tt(t,"a","where"),s=tt(n,"b","where"),a=tt(e,"condition","where","bool"),i=Nt(Nt(a.shape,r.shape),s.shape),o={condition:In(a,i),t:In(r,i),e:In(s,i)};return be.runKernel("Select",o)}});function En(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return be.runKernel("Range",{},s)}const kn=nt({threshold_:function(e,t="binary",n=!1,s=.5){const a=tt(e,"image","threshold"),i=a.shape[0]*a.shape[1];let o,l,c,u,h=dt(qt([s]),255);if(r(3===a.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`)),r(3===a.shape[2]||1===a.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`)),r("int32"===a.dtype||"float32"===a.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`)),r("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===a.shape[2]){[o,l,c]=Jt(a,[1,1,1],-1);const e=dt(o,.2989),t=dt(l,.587),n=dt(c,.114);u=ct(ct(e,t),n)}else u=e;var d,f;"otsu"===t&&(h=function(e,t){let n,r,s,a,i,o,l=qt([-1]),c=qt([0]),u=qt([0]);for(let h=0;h<e.size-1;h++){n=Ht(e,0,h+1),r=Ht(e,h+1),i=ht(wn(n),t),o=ht(wn(r),t);const d=wn(dt(n,En(0,n.size)));s=ht(d,wn(n));const f=kt(r.shape,n.size),p=ct(En(0,r.size),f),m=dt(r,p);a=ht(wn(m),wn(r));const g=xt(s,a),y=xt(s,a),b=dt(i,o);u=dt(dt(b,g),y);const w=bn(u,c);c=vn(w,u,c),l=vn(w,qt([h]),l)}return l}(gn(rt(Tn(u),"int32"),gt(d=[],undefined,Xe(d,f),f),256),i));const p=n?yn(u,h):bn(u,h);return rt(dt(p,255),"int32")}}),Sn=nt({transform_:function(e,t,n="nearest",s="constant",a=0,i){const o=tt(e,"image","transform","float32"),l=tt(t,"transforms","transform","float32");r(4===o.rank,(()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`)),r(2===l.rank&&(l.shape[0]===o.shape[0]||1===l.shape[0])&&8===l.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),r(null==i||2===i.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`));const c={image:o,transforms:l},u={interpolation:n,fillMode:s,fillValue:a,outputShape:i};return be.runKernel("Transform",c,u)}});var xn;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(xn||(xn={}));const _n={flipLeftRight:Yt,grayscaleToRGB:Zt,resizeNearestNeighbor:mn,resizeBilinear:pn,rgbToGrayscale:tn,rotateWithOffset:nn,cropAndResize:Qt,nonMaxSuppression:sn,nonMaxSuppressionAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=tt(e,"boxes","nonMaxSuppressionAsync"),i=tt(t,"scores","nonMaxSuppressionAsync"),o=rn(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),c=l[0],u=l[1],{selectedIndices:h}=function(e,t,n,r,s){return ln(e,t,n,r,s,0)}(c,u,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),qt(h,"int32")},nonMaxSuppressionWithScore:dn,nonMaxSuppressionWithScoreAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=tt(e,"boxes","nonMaxSuppressionAsync"),o=tt(t,"scores","nonMaxSuppressionAsync"),l=rn(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const c=await Promise.all([i.data(),o.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:f}=function(e,t,n,r,s,a){return ln(e,t,n,r,s,a,!0)}(u,h,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:qt(d,"int32"),selectedScores:qt(f)}},nonMaxSuppressionPadded:fn,nonMaxSuppressionPaddedAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=tt(e,"boxes","nonMaxSuppressionAsync"),o=tt(t,"scores","nonMaxSuppressionAsync"),l=rn(i,o,n,r,s,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,f]=await Promise.all([i.data(),o.data()]),{selectedIndices:p,validOutputs:m}=function(e,t,n,r,s,a){return ln(e,t,n,r,s,0,!1,a,!0)}(d,f,c,u,h,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:qt(p,"int32"),validOutputs:yt(m,"int32")}},threshold:kn,transform:Sn};var Nn,An;function Rn(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))}function Mn(e,t){var n,r,s,a,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return a={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function o(o){return function(l){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;a&&(a=0,o[0]&&(i=0)),i;)try{if(n=1,r&&(s=2&o[0]?r.return:o[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,o[1])).done)return s;switch(r=0,s&&(o=[2&o[0],s.value]),o[0]){case 0:case 1:s=o;break;case 4:return i.label++,{value:o[1],done:!1};case 5:i.label++,r=o[1],o=[0];continue;case 7:o=i.ops.pop(),i.trys.pop();continue;default:if(!((s=(s=i.trys).length>0&&s[s.length-1])||6!==o[0]&&2!==o[0])){i=0;continue}if(3===o[0]&&(!s||o[1]>s[0]&&o[1]<s[3])){i.label=o[1];break}if(6===o[0]&&i.label<s[1]){i.label=s[1],s=o;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(o);break}s[2]&&i.ops.pop(),i.trys.pop();continue}o=t.call(e,i)}catch(e){o=[6,e],r=0}finally{n=s=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,l])}}}function Dn(e,t,n){if(n||2===arguments.length)for(var r,s=0,a=t.length;s<a;s++)!r&&s in t||(r||(r=Array.prototype.slice.call(t,0,s)),r[s]=t[s]);return e.concat(r||Array.prototype.slice.call(t))}function Bn(e){return[Math.abs(e.endPoint[0]-e.startPoint[0]),Math.abs(e.endPoint[1]-e.startPoint[1])]}function Fn(e){return[e.startPoint[0]+(e.endPoint[0]-e.startPoint[0])/2,e.startPoint[1]+(e.endPoint[1]-e.startPoint[1])/2]}function Pn(e,t){void 0===t&&(t=1.5);var n=Fn(e),r=Bn(e),s=[t*r[0]/2,t*r[1]/2];return{startPoint:[n[0]-s[0],n[1]-s[1]],endPoint:[n[0]+s[0],n[1]+s[1]],palmLandmarks:e.palmLandmarks}}function On(e){var t=Fn(e),n=Bn(e),r=Math.max.apply(Math,n)/2;return{startPoint:[t[0]-r,t[1]-r],endPoint:[t[0]+r,t[1]+r],palmLandmarks:e.palmLandmarks}}function Cn(e,t){var n=[e.endPoint[0]-e.startPoint[0],e.endPoint[1]-e.startPoint[1]],r=[n[0]*t[0],n[1]*t[1]];return{startPoint:[e.startPoint[0]+r[0],e.startPoint[1]+r[1]],endPoint:[e.endPoint[0]+r[0],e.endPoint[1]+r[1]],palmLandmarks:e.palmLandmarks}}!function(){for(const e of Mt)vt(e)}(),I().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(Nn||(Nn={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(An||(An={})),Error,new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]),"function"==typeof SuppressedError&&SuppressedError,function(){function e(e,t,n,r,a,i){this.model=e,this.width=t,this.height=n,this.iouThreshold=a,this.scoreThreshold=i,this.anchors=r.map((function(e){return[e.x_center,e.y_center]})),this.anchorsTensor=function(e,t,n){if(s(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Xe(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return gt(e,t,r,n)}(this.anchors),this.inputSizeTensor=qt([t,n]),this.doubleInputSizeTensor=qt([2*t,2*n])}e.prototype.normalizeBoxes=function(e){var t=this;return it((function(){var n=Ht(e,[0,0],[-1,2]),r=Ht(e,[0,2],[-1,2]),s=ct(ht(n,t.inputSizeTensor),t.anchorsTensor),a=ht(r,t.doubleInputSizeTensor),i=dt(xt(s,a),t.inputSizeTensor),o=dt(ct(s,a),t.inputSizeTensor);return Gt([i,o],1)}))},e.prototype.normalizeLandmarks=function(e,t){var n=this;return it((function(){var r=ct(ht(Wt(e,[-1,7,2]),n.inputSizeTensor),n.anchors[t]);return dt(r,n.inputSizeTensor)}))},e.prototype.getBoundingBoxes=function(e){return Rn(this,void 0,void 0,(function(){var t,n,r,s,a,i,o,l,c,u,h,d,f,p,m,g=this;return Mn(this,(function(y){switch(y.label){case 0:return t=it((function(){return dt(xt(e,.5),2)})),"webgl"===lt()?(r=I().get("WEBGL_PACK_DEPTHWISECONV"),I().set("WEBGL_PACK_DEPTHWISECONV",!0),n=this.model.predict(t),I().set("WEBGL_PACK_DEPTHWISECONV",r)):n=this.model.predict(t),s=Kt(n),a=it((function(){return Kt(Vt(Ht(s,[0,0],[-1,1])))})),i=Ht(s,[0,1],[-1,4]),o=this.normalizeBoxes(i),l=console.warn,console.warn=function(){},c=_n.nonMaxSuppression(o,a,1,this.iouThreshold,this.scoreThreshold),console.warn=l,[4,c.array()];case 1:return u=y.sent(),h=[t,n,c,s,o,i,a],0===u.length?(h.forEach((function(e){return e.dispose()})),[2,null]):(d=u[0],f=Ht(o,[d,0],[1,-1]),p=Ht(s,[d,5],[1,14]),m=it((function(){return Wt(g.normalizeLandmarks(p,d),[-1,2])})),h.push(p),h.forEach((function(e){return e.dispose()})),[2,{boxes:f,palmLandmarks:m}])}}))}))},e.prototype.estimateHandBounds=function(e){return Rn(this,void 0,void 0,(function(){var t,n,r,s,a,i,o,l,c=this;return Mn(this,(function(u){switch(u.label){case 0:return t=e.shape[1],n=e.shape[2],r=it((function(){return ht(_n.resizeBilinear(e,[c.width,c.height]),255)})),[4,this.getBoundingBoxes(r)];case 1:return null===(s=u.sent())?(r.dispose(),[2,null]):(a=s.boxes.arraySync(),i=a[0].slice(0,2),o=a[0].slice(2,4),l=s.palmLandmarks.arraySync(),r.dispose(),s.boxes.dispose(),s.palmLandmarks.dispose(),[2,(h={startPoint:i,endPoint:o,palmLandmarks:l},d=[n/this.width,t/this.height],{startPoint:[h.startPoint[0]*d[0],h.startPoint[1]*d[1]],endPoint:[h.endPoint[0]*d[0],h.endPoint[1]*d[1]],palmLandmarks:h.palmLandmarks.map((function(e){return[e[0]*d[0],e[1]*d[1]]}))})])}var h,d}))}))}}();var $n={thumb:[1,2,3,4],indexFinger:[5,6,7,8],middleFinger:[9,10,11,12],ringFinger:[13,14,15,16],pinky:[17,18,19,20],palmBase:[0]},Ln=function(e,t){return[[1,0,e],[0,1,t],[0,0,1]]};function zn(e,t){for(var n=0,r=0;r<e.length;r++)n+=e[r]*t[r];return n}function Un(e,t){for(var n=[],r=0;r<e.length;r++)n.push(e[r][t]);return n}function Gn(e,t){for(var n=[],r=e.length,s=0;s<r;s++){n.push([]);for(var a=0;a<r;a++)n[s].push(zn(e[s],Un(t,a)))}return n}function jn(e,t){var n=Math.cos(e),r=Math.sin(e),s=[[n,-r,0],[r,n,0],[0,0,1]],a=Gn(Ln(t[0],t[1]),s);return Gn(a,Ln(-t[0],-t[1]))}function Wn(e,t){return[zn(e,t[0]),zn(e,t[1])]}var Vn=[0,-.4],Hn=[0,-.1],Kn=[0,5,9,13,17,1,2];!function(){function e(e,t,n,r,s,a){this.boundingBoxDetector=e,this.meshDetector=t,this.meshWidth=n,this.meshHeight=r,this.maxContinuousChecks=s,this.detectionConfidence=a,this.regionsOfInterest=[],this.runsWithoutHandDetector=0,this.maxHandsNumber=1}e.prototype.getBoxForPalmLandmarks=function(e,t){var n=e.map((function(e){return Wn(Dn(Dn([],e,!0),[1],!1),t)}));return Pn(On(Cn(this.calculateLandmarksBoundingBox(n),Vn)),3)},e.prototype.getBoxForHandLandmarks=function(e){for(var t=Pn(On(Cn(this.calculateLandmarksBoundingBox(e),Hn)),1.65),n=[],r=0;r<Kn.length;r++)n.push(e[Kn[r]].slice(0,2));return t.palmLandmarks=n,t},e.prototype.transformRawCoords=function(e,t,n,r){var s,a,i,o,l=this,c=Bn(t),u=[c[0]/this.meshWidth,c[1]/this.meshHeight],h=e.map((function(e){return[u[0]*(e[0]-l.meshWidth/2),u[1]*(e[1]-l.meshHeight/2),e[2]]})),d=jn(n,[0,0]),f=h.map((function(e){return Dn(Dn([],Wn(e,d),!0),[e[2]],!1)})),p=(a=[[(s=r)[0][0],s[1][0]],[s[0][1],s[1][1]]],i=[s[0][2],s[1][2]],o=[-zn(a[0],i),-zn(a[1],i)],[a[0].concat(o[0]),a[1].concat(o[1]),[0,0,1]]),m=Dn(Dn([],Fn(t),!0),[1],!1),g=[zn(m,p[0]),zn(m,p[1])];return f.map((function(e){return[e[0]+g[0],e[1]+g[1],e[2]]}))},e.prototype.estimateHand=function(e){return Rn(this,void 0,void 0,(function(){var t,n,r,s,a,i,o,l,c,u,h,d,f,p,m,g,y,b,w,T;return Mn(this,(function(v){switch(v.label){case 0:return!0!==(t=this.shouldUpdateRegionsOfInterest())?[3,2]:[4,this.boundingBoxDetector.estimateHandBounds(e)];case 1:return null===(n=v.sent())?(e.dispose(),this.regionsOfInterest=[],[2,null]):(this.updateRegionsOfInterest(n,!0),this.runsWithoutHandDetector=0,[3,3]);case 2:this.runsWithoutHandDetector++,v.label=3;case 3:return r=this.regionsOfInterest[0],s=function(e,t){var n;return(n=Math.PI/2-Math.atan2(-(t[1]-e[1]),t[0]-e[0]))-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}(r.palmLandmarks[0],r.palmLandmarks[2]),a=Fn(r),i=[a[0]/e.shape[2],a[1]/e.shape[1]],o=_n.rotateWithOffset(e,s,0,i),l=jn(-s,a),c=!0===t?this.getBoxForPalmLandmarks(r.palmLandmarks,l):r,u=function(e,t,n){var r=t.shape[1],s=t.shape[2],a=[[e.startPoint[1]/r,e.startPoint[0]/s,e.endPoint[1]/r,e.endPoint[0]/s]];return _n.cropAndResize(t,a,[0],n)}(c,o,[this.meshWidth,this.meshHeight]),h=ht(u,255),u.dispose(),o.dispose(),"webgl"===lt()?(f=I().get("WEBGL_PACK_DEPTHWISECONV"),I().set("WEBGL_PACK_DEPTHWISECONV",!0),d=this.meshDetector.predict(h),I().set("WEBGL_PACK_DEPTHWISECONV",f)):d=this.meshDetector.predict(h),p=d[0],m=d[1],h.dispose(),g=p.dataSync()[0],p.dispose(),g<this.detectionConfidence?(m.dispose(),this.regionsOfInterest=[],[2,null]):(y=Wt(m,[-1,3]),b=y.arraySync(),m.dispose(),y.dispose(),w=this.transformRawCoords(b,c,s,l),T=this.getBoxForHandLandmarks(w),this.updateRegionsOfInterest(T,!1),[2,{landmarks:w,handInViewConfidence:g,boundingBox:{topLeft:T.startPoint,bottomRight:T.endPoint}}])}}))}))},e.prototype.calculateLandmarksBoundingBox=function(e){var t=e.map((function(e){return e[0]})),n=e.map((function(e){return e[1]}));return{startPoint:[Math.min.apply(Math,t),Math.min.apply(Math,n)],endPoint:[Math.max.apply(Math,t),Math.max.apply(Math,n)]}},e.prototype.updateRegionsOfInterest=function(e,t){if(t)this.regionsOfInterest=[e];else{var n=this.regionsOfInterest[0],r=0;if(null!=n&&null!=n.startPoint){var s=e.startPoint,a=s[0],i=s[1],o=e.endPoint,l=o[0],c=o[1],u=n.startPoint,h=u[0],d=u[1],f=n.endPoint,p=f[0],m=f[1],g=Math.max(a,h),y=Math.max(i,d),b=(Math.min(l,p)-g)*(Math.min(c,m)-y);r=b/((l-a)*(c-i)+(p-h)*(m-i)-b)}this.regionsOfInterest[0]=r>.8?n:e}},e.prototype.shouldUpdateRegionsOfInterest=function(){return this.regionsOfInterest.length!==this.maxHandsNumber||this.runsWithoutHandDetector>=this.maxContinuousChecks}}(),function(){function e(e){this.pipeline=e}e.getAnnotations=function(){return $n},e.prototype.estimateHands=function(e,t){return void 0===t&&(t=!1),Rn(this,void 0,void 0,(function(){var n,r,s,a,i,o,l,c,u;return Mn(this,(function(h){switch(h.label){case 0:return n=function(e){return e instanceof ee?[e.shape[0],e.shape[1]]:[e.height,e.width]}(e),r=n[1],s=it((function(){return e instanceof ee||(e=zt(e)),jt(rt(e,"float32"))})),[4,this.pipeline.estimateHand(s)];case 1:if(a=h.sent(),s.dispose(),null===a)return[2,[]];for(i=a,!0===t&&(i=function(e,t){var n=e.handInViewConfidence,r=e.landmarks,s=e.boundingBox;return{handInViewConfidence:n,landmarks:r.map((function(e){return[t-1-e[0],e[1],e[2]]})),boundingBox:{topLeft:[t-1-s.topLeft[0],s.topLeft[1]],bottomRight:[t-1-s.bottomRight[0],s.bottomRight[1]]}}}(a,r)),o={},l=0,c=Object.keys($n);l<c.length;l++)u=c[l],o[u]=$n[u].map((function(e){return i.landmarks[e]}));return[2,[{handInViewConfidence:i.handInViewConfidence,boundingBox:i.boundingBox,landmarks:i.landmarks,annotations:o}]]}}))}))}}(),chrome.runtime.onInstalled.addListener((()=>{chrome.contextMenus.create({id:"gesture-control",title:"Ativar Controle por Gestos",contexts:["all"]})})),chrome.contextMenus.onClicked.addListener(((e,t)=>{"gesture-control"===e.menuItemId&&chrome.scripting.executeScript({target:{tabId:t.id},files:["src/content.js"]})})),chrome.runtime.onMessage.addListener(((e,t,n)=>{const{action:r,tabId:s}=e;console.log("Mensagem recebida no service worker:",e),s&&("startGestureControl"===r&&chrome.scripting.executeScript({target:{tabId:s},files:["src/content.js"]}),"pauseGestureControl"===r&&chrome.scripting.executeScript({target:{tabId:s},func:()=>{console.log("Pausando gestos..."),window.__gesturePaused=!0}}),"stopGestureControl"===r&&chrome.scripting.executeScript({target:{tabId:s},func:()=>{console.log("Encerrando controle de gestos...");const e=document.getElementById("gesture-video-container");if(e){const t=e.querySelector("video");t?.srcObject&&t.srcObject.getTracks().forEach((e=>e.stop())),e.remove()}window.__gesturePaused=!1,window.__gestureStop=!0}}))}))})()})();